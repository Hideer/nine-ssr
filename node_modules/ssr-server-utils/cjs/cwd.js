"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.copyReactContext = exports.normalizeEndPath = exports.normalizeStartPath = exports.cryptoAsyncChunkName = exports.addAsyncChunk = exports.readAsyncChunk = exports.execPromisify = exports.checkVite = exports.copyViteConfig = exports.accessFile = exports.processError = exports.getLocalNodeModules = exports.loadPlugin = exports.isFaaS = exports.getUserConfig = exports.getPagesDir = exports.getFeDir = exports.getCwd = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const child_process_1 = require("child_process");
const util_1 = require("util");
const getCwd = () => {
    var _a;
    return (0, path_1.resolve)(process.cwd(), (_a = process.env.APP_ROOT) !== null && _a !== void 0 ? _a : '');
};
exports.getCwd = getCwd;
const getFeDir = () => {
    var _a;
    return (0, path_1.resolve)(getCwd(), (_a = process.env.FE_ROOT) !== null && _a !== void 0 ? _a : 'web');
};
exports.getFeDir = getFeDir;
const getPagesDir = () => {
    return (0, path_1.resolve)(getFeDir(), 'pages');
};
exports.getPagesDir = getPagesDir;
const getUserConfig = () => {
    var _a;
    const config = require((0, path_1.resolve)(getCwd(), './build/config'));
    return (_a = config.userConfig) !== null && _a !== void 0 ? _a : config;
};
exports.getUserConfig = getUserConfig;
const loadPlugin = () => {
    return require((0, path_1.resolve)(getCwd(), 'plugin'));
};
exports.loadPlugin = loadPlugin;
const readAsyncChunk = async () => {
    const cwd = getCwd();
    try {
        const str = (await fs_1.promises.readFile((0, path_1.resolve)(cwd, './build/asyncChunkMap.json'))).toString();
        return JSON.parse(str);
    }
    catch (error) {
        return {};
    }
};
exports.readAsyncChunk = readAsyncChunk;
const addAsyncChunk = async (dynamicCssOrder, webpackChunkName) => {
    const arr = [];
    const asyncChunkMap = await readAsyncChunk();
    for (const key in asyncChunkMap) {
        if (asyncChunkMap[key].includes(webpackChunkName)) {
            arr.push(`${key}.css`);
        }
    }
    return arr.concat(dynamicCssOrder);
};
exports.addAsyncChunk = addAsyncChunk;
const cyrb53 = function (str, seed = 0) {
    let h1 = 0xdeadbeef ^ seed;
    let h2 = 0x41c6ce57 ^ seed;
    for (let i = 0, ch; i < str.length; i++) {
        ch = str.charCodeAt(i);
        h1 = Math.imul(h1 ^ ch, 2654435761);
        h2 = Math.imul(h2 ^ ch, 1597334677);
    }
    h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);
    h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);
    return 4294967296 * (2097151 & h2) + (h1 >>> 0);
};
const cryptoAsyncChunkName = (chunks, asyncChunkMap) => {
    // 加密异步模块 name，防止名称过长
    const allChunksNames = chunks.map((item) => item.name).join('~');
    const allChunksNamesArr = allChunksNames.split('~');
    const cryptoAllChunksNames = String(cyrb53(allChunksNames));
    if (allChunksNamesArr.length >= 2 && !asyncChunkMap[cryptoAllChunksNames]) {
        asyncChunkMap[cryptoAllChunksNames] = allChunksNamesArr;
    }
    return cryptoAllChunksNames;
};
exports.cryptoAsyncChunkName = cryptoAsyncChunkName;
const isFaaS = async (fun) => {
    const result = await fs_1.promises.access((0, path_1.resolve)(getCwd(), fun ? 'template.yml' : 'f.yml'))
        .then(() => true)
        .catch(() => false);
    return result;
};
exports.isFaaS = isFaaS;
const getLocalNodeModules = () => (0, path_1.resolve)(__dirname, '../../../node_modules');
exports.getLocalNodeModules = getLocalNodeModules;
const processError = (err) => {
    if (err) {
        console.log(err);
        process.exit(1);
    }
};
exports.processError = processError;
const accessFile = async (file) => {
    const result = await fs_1.promises.access(file)
        .then(() => true)
        .catch(() => false);
    return result;
};
exports.accessFile = accessFile;
const checkVite = async () => {
    const result = await accessFile((0, path_1.resolve)(getCwd(), './node_modules/vite/package.json'));
    if (!result) {
        const version = require((0, path_1.resolve)(getCwd(), './package.json')).dependencies.vue;
        let plugin = '';
        if (version) {
            plugin = /^.?3/.test(version) ? '@vitejs/plugin-vue' : 'vite-plugin-vue2';
        }
        else {
            plugin = '@vitejs/plugin-react-refresh';
        }
        console.log(`当前项目缺少 vite 依赖，请根据实际技术栈安装 vite ${plugin}${version && !/^.?3/.test(version) ? '@1.4.4' : ''} 或 其他对应插件`);
        if (version && !/^.?3/.test(version)) {
            console.log('vue2 场景下使用 Vite 必须安装固定版本 vite-plugin-vue2@1.4.4');
        }
        return false;
    }
    return true;
};
exports.checkVite = checkVite;
const copyViteConfig = async () => {
    var _a, _b;
    // 如果当前项目没有 vite.config 则复制默认的文件
    const result = await accessFile((0, path_1.resolve)(getCwd(), './vite.config.js'));
    if (!result) {
        const version = require((0, path_1.resolve)(getCwd(), './package.json')).dependencies.vue;
        console.log('vite.config.js not found, will be created automatically');
        let folder = '';
        if (version) {
            folder = /^.?3/.test(version) ? 'ssr-plugin-vue3' : 'ssr-plugin-vue';
        }
        else {
            folder = 'ssr-plugin-react';
        }
        await fs_1.promises.copyFile((0, path_1.resolve)(getCwd(), `./node_modules/${folder}/src/config/vite.config.tpl`), (0, path_1.resolve)(getCwd(), './vite.config.js'));
    }
    else {
        // 如果有 vite.config.js 则检测是不是最新的
        const buildAlias = (_b = (_a = require((0, path_1.resolve)(getCwd(), './vite.config.js')).resolve) === null || _a === void 0 ? void 0 : _a.alias) === null || _b === void 0 ? void 0 : _b._build;
        if (!buildAlias) {
            throw new Error('当前 vite.config.js 为旧版，请删除后由框架重新创建或手动添加新的 alias 规则 \'_build\': join(process.cwd(), \'./build\')');
        }
    }
};
exports.copyViteConfig = copyViteConfig;
const copyReactContext = async () => {
    await fs_1.promises.copyFile((0, path_1.resolve)(getCwd(), './node_modules/ssr-plugin-react/src/entry/create-context.ts'), (0, path_1.resolve)(getCwd(), './build/create-context.ts'));
};
exports.copyReactContext = copyReactContext;
const execPromisify = (0, util_1.promisify)(child_process_1.exec);
exports.execPromisify = execPromisify;
const normalizeStartPath = (path) => {
    if (path.startsWith('//')) {
        path = path.replace('//', '/');
    }
    if (!path.startsWith('/')) {
        path = `/${path}`;
    }
    return path;
};
exports.normalizeStartPath = normalizeStartPath;
const normalizeEndPath = (path) => {
    if (!path.endsWith('/')) {
        path = `${path}/`;
    }
    return path;
};
exports.normalizeEndPath = normalizeEndPath;
