"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findNpm = exports.findNpmModule = exports.loadNpm = exports.installNpm = exports.getCoreBaseDir = void 0;
const path_1 = require("path");
const fs_1 = require("fs");
const child_process_1 = require("child_process");
const assert = require("assert");
const os_1 = require("os");
const getCoreBaseDir = () => {
    return (0, child_process_1.execSync)('npm root').toString().replace(/\n$/, '');
};
exports.getCoreBaseDir = getCoreBaseDir;
async function getNpmPath(scope, npmName, npmRegistry) {
    const findNmResult = (0, exports.findNpmModule)(scope.cwd || process.cwd(), npmName);
    if (findNmResult) {
        return findNmResult;
    }
    const currentNodeModules = (0, exports.getCoreBaseDir)();
    const localNpmPath = (0, path_1.join)(currentNodeModules, npmName);
    if ((0, fs_1.existsSync)(localNpmPath)) {
        return localNpmPath;
    }
    let baseDir = (0, path_1.join)(currentNodeModules, '../');
    if (!(0, fs_1.existsSync)(baseDir)) {
        baseDir = process.cwd();
    }
    const pkgJson = (0, path_1.join)(baseDir, 'package.json');
    if (!(0, fs_1.existsSync)(pkgJson)) {
        (0, fs_1.writeFileSync)(pkgJson, '{}');
    }
    scope.coreInstance.cli.log(`Installing ${npmName}`);
    await installNpm({
        baseDir,
        register: npmRegistry,
        npmName,
        mode: 'production --no-save',
    });
    return (0, path_1.join)(baseDir, `node_modules/${npmName}`);
}
// yarn: yarn add mod --dev
// npm: npm i mod --no-save
// yarn + lerna: yarn add mod --ignore-workspace-root-check
// npm + lerna: npm i mod --no-save
async function installNpm(options) {
    const { baseDir, register = 'npm', npmName, slience, registerPath, isLerna, } = options;
    let { installCmd = 'i', mode } = options;
    if (/yarn/.test(register)) {
        if (!options.installCmd) {
            // yarn add
            installCmd = 'add';
        }
        if (mode === undefined) {
            mode = isLerna ? 'ignore-workspace-root-check' : 'dev';
        }
    }
    else {
        if (mode === undefined) {
            mode = 'no-save';
        }
    }
    const cmd = `${register} ${installCmd} ${npmName}${mode ? ` --${mode}` : ''}${registerPath ? ` --registry=${registerPath}` : ''}`;
    return new Promise((resolved, rejected) => {
        const execProcess = (0, child_process_1.exec)(cmd, {
            cwd: baseDir,
        }, (err, result) => {
            if (err) {
                return rejected(err);
            }
            resolved(result.replace(/\n$/, '').replace(/^\s*|\s*$/, ''));
        });
        execProcess.stdout.on('data', data => {
            if (!slience) {
                console.log(data);
            }
        });
    });
}
exports.installNpm = installNpm;
async function loadNpm(scope, npmName, npmRegistry) {
    try {
        const npmPath = await getNpmPath(scope, npmName, npmRegistry);
        assert(npmPath, 'empty npm path');
        const plugin = require(npmPath);
        scope.addPlugin(plugin);
    }
    catch (e) {
        if (scope && scope.debug) {
            scope.debug('Load NPM Error', e);
        }
    }
}
exports.loadNpm = loadNpm;
const findNpmModule = (cwd, modName) => {
    const modPath = (0, path_1.join)(cwd, 'node_modules', modName);
    if ((0, fs_1.existsSync)(modPath)) {
        return modPath;
    }
    const parentCwd = (0, path_1.join)(cwd, '../');
    if (parentCwd !== cwd) {
        return (0, exports.findNpmModule)(parentCwd, modName);
    }
};
exports.findNpmModule = findNpmModule;
const findNpm = (argv) => {
    let npm = 'npm';
    let registry = '';
    // 先找npm客户端
    if (argv === null || argv === void 0 ? void 0 : argv.npm) {
        npm = argv.npm;
    }
    else if (process.env.npm_config_user_agent &&
        /yarn/.test(process.env.npm_config_user_agent)) {
        npm = 'yarn';
    }
    else if (process.env.npm_execpath &&
        /yarn/.test(process.env.npm_execpath)) {
        npm = 'yarn';
    }
    else if (process.env.yarn_registry) {
        npm = 'yarn';
    }
    else {
        const npmList = ['cnpm'];
        const currentPlatform = (0, os_1.platform)();
        const cmd = npmList.find(cmd => {
            if (currentPlatform === 'win32') {
                // for windows
                try {
                    const find = (0, child_process_1.execSync)(`where ${cmd}`).toString();
                    // windows的命令路径至少会有 C/D/E:\ 前缀
                    if (find.indexOf(':\\') !== -1) {
                        return cmd;
                    }
                }
                catch (_a) {
                    //
                }
            }
            else {
                // for mac/linux
                try {
                    const find = (0, child_process_1.execSync)(`which ${cmd}`).toString();
                    // 没有找到not found
                    if (find.indexOf('not found') === -1) {
                        return cmd;
                    }
                }
                catch (_b) {
                    //
                }
            }
        });
        if (cmd) {
            npm = cmd;
        }
    }
    // registry
    if ((argv === null || argv === void 0 ? void 0 : argv.registry) !== undefined) {
        registry = argv.registry || '';
    }
    else if (npm === 'yarn' && process.env.yarn_registry) {
        registry = process.env.yarn_registry;
    }
    else if (process.env.npm_config_registry) {
        registry = process.env.npm_config_registry;
    }
    else {
        // language is zh_CN
        if (process.env.LANG === 'zh_CN.UTF-8') {
            registry = 'https://registry.npm.taobao.org';
        }
    }
    return {
        cmd: `${npm}${registry ? ` --registry=${registry}` : ''}`,
        npm,
        registry,
    };
};
exports.findNpm = findNpm;
//# sourceMappingURL=npm.js.map