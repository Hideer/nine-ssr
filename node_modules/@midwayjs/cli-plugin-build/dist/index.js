"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuildPlugin = void 0;
const command_core_1 = require("@midwayjs/command-core");
const path_1 = require("path");
const fs_extra_1 = require("fs-extra");
const mwcc_1 = require("@midwayjs/mwcc");
const faas_code_analysis_1 = require("@midwayjs/faas-code-analysis");
const ts = require("typescript");
class BuildPlugin extends command_core_1.BasePlugin {
    constructor() {
        super(...arguments);
        this.isMidwayHooks = false;
        this.midwayBinBuild = {};
        this.midwayCliConfig = {};
        this.commands = {
            build: {
                lifecycleEvents: [
                    'formatOptions',
                    'clean',
                    'copyFile',
                    'compile',
                    'emit',
                    'complete',
                ],
                options: {
                    clean: {
                        usage: 'clean build target dir',
                        shortcut: 'c',
                    },
                    project: {
                        usage: 'project file location',
                        shortcut: 'p',
                    },
                    srcDir: {
                        usage: 'source code path',
                    },
                    outDir: {
                        usage: 'build out path',
                    },
                    tsConfig: {
                        usage: 'json string / file path / object',
                    },
                    buildCache: {
                        usage: 'save build cache',
                    },
                    exclude: {
                        usage: 'copy file exclude',
                    },
                    include: {
                        usage: 'copy file include',
                    },
                },
            },
        };
        this.hooks = {
            'build:formatOptions': this.formatOptions.bind(this),
            'build:clean': this.clean.bind(this),
            'build:copyFile': this.copyFile.bind(this),
            'build:compile': this.compile.bind(this),
            'build:emit': this.emit.bind(this),
            'build:complete': this.complete.bind(this),
        };
    }
    async formatOptions() {
        const midwayConfig = [
            (0, path_1.join)(this.core.cwd, 'midway.config.ts'),
            (0, path_1.join)(this.core.cwd, 'midway.config.js'),
        ].find(file => (0, fs_extra_1.existsSync)(file));
        if (midwayConfig) {
            this.isMidwayHooks = true;
            const modInfo = (0, command_core_1.findNpmModule)(this.core.cwd, '@midwayjs/hooks-core');
            if (modInfo) {
                const { getConfig } = require(modInfo);
                const config = getConfig(this.core.cwd);
                if (config.source) {
                    this.options.srcDir = config.source;
                }
            }
        }
        const packageJsonPath = (0, path_1.join)(this.core.cwd, 'package.json');
        if ((0, fs_extra_1.existsSync)(packageJsonPath)) {
            const pkgJson = JSON.parse((0, fs_extra_1.readFileSync)(packageJsonPath).toString());
            this.midwayBinBuild = pkgJson['midway-bin-build'] || {};
            this.midwayCliConfig = pkgJson['midway-cli'] || {};
        }
    }
    async clean() {
        if (!this.options.clean) {
            return;
        }
        const outdir = this.getOutDir();
        if ((0, fs_extra_1.existsSync)(outdir)) {
            await (0, fs_extra_1.remove)(outdir);
        }
    }
    getOutDir() {
        if (this.options.outDir) {
            return this.options.outDir;
        }
        const tsConfig = this.getTsConfig();
        this.core.debug('TSConfig', tsConfig);
        const projectFile = this.getProjectFile();
        this.core.debug('ProjectFile', projectFile);
        return (this.getCompilerOptions(tsConfig, 'outDir', (0, path_1.dirname)(projectFile)) ||
            'dist');
    }
    async copyFile() {
        const outDir = this.getOutDir();
        this.core.debug('CopyFile TargetDir', outDir);
        const exclude = this.options.exclude ? this.options.exclude.split(',') : [];
        const sourceDir = (0, path_1.join)(this.core.cwd, this.options.srcDir || 'src');
        const targetDir = (0, path_1.join)(this.core.cwd, outDir);
        await (0, faas_code_analysis_1.copyFiles)({
            sourceDir,
            targetDir,
            defaultInclude: this.midwayBinBuild.include
                ? this.midwayBinBuild.include
                : ['**/*'],
            exclude: ['**/*.ts', '**/*.js'].concat(exclude),
            log: path => {
                this.core.cli.log(`   - Copy ${path}`);
            },
        });
        // midway core DEFAULT_IGNORE_PATTERN
        let include = [
            '**/public/**/*.js',
            '**/view/**/*.js',
            '**/views/**/*.js',
            '**/app/extend/**/*.js',
        ];
        if (this.options.include !== undefined) {
            include = this.options.include ? this.options.include.split(',') : [];
        }
        if (include.length) {
            await (0, faas_code_analysis_1.copyFiles)({
                sourceDir,
                targetDir,
                defaultInclude: include,
                exclude,
                log: path => {
                    this.core.cli.log(`   - Copy ${path}`);
                },
            });
        }
        this.core.cli.log('   - Copy Complete');
    }
    async compile() {
        const rootDir = this.getTsCodeRoot();
        this.core.debug('rootDir', rootDir);
        const outDir = this.getOutDir();
        this.core.debug('outDir', outDir);
        const { cwd } = this.core;
        const { config } = (0, mwcc_1.resolveTsConfigFile)(cwd, undefined, this.options.tsConfig, this.getStore('mwccHintConfig', 'global'), this.isMidwayHooks
            ? {
                compilerOptions: {
                    sourceRoot: rootDir,
                    rootDir,
                    outDir,
                },
                include: [rootDir],
            }
            : {
                compilerOptions: {
                    sourceRoot: rootDir,
                },
            });
        this.core.debug('Compile TSConfig', config);
        this.compilerHost = new mwcc_1.CompilerHost(cwd, config);
        this.program = new mwcc_1.Program(this.compilerHost);
    }
    async emit() {
        var _a, _b;
        const { diagnostics } = await this.program.emit();
        if (diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.length) {
            const error = diagnostics.find(diagnostic => {
                return diagnostic.category === ts.DiagnosticCategory.Error;
            });
            if (error) {
                const errorPath = `(${(0, path_1.relative)(this.core.cwd, error.file.fileName)})`;
                if (!((_b = (_a = this.midwayCliConfig) === null || _a === void 0 ? void 0 : _a.experimentalFeatures) === null || _b === void 0 ? void 0 : _b.ignoreTsError)) {
                    throw new Error(`TS Error: ${error.messageText}${errorPath}`);
                }
            }
        }
        // clear build cache
        if (!this.options.buildCache) {
            const { cwd } = this.core;
            const outDir = this.getOutDir();
            const cacheList = [
                (0, path_1.join)(cwd, outDir, '.mwcc-cache'),
                (0, path_1.join)(cwd, outDir, 'midway.build.json'),
            ];
            for (const cacheFile of cacheList) {
                if ((0, fs_extra_1.existsSync)(cacheFile)) {
                    await (0, fs_extra_1.remove)(cacheFile);
                }
            }
        }
    }
    getTsCodeRoot() {
        return (0, path_1.resolve)(this.core.cwd, this.options.srcDir || 'src');
    }
    getCompilerOptions(tsConfig, optionKeyPath, projectDir) {
        var _a;
        // if projectFile extended and without the option,
        // get setting from its parent
        if (tsConfig && tsConfig.extends) {
            if (!tsConfig.compilerOptions ||
                (tsConfig.compilerOptions && !tsConfig.compilerOptions[optionKeyPath])) {
                return this.getCompilerOptions(require((0, path_1.join)(projectDir, tsConfig.extends)), optionKeyPath, { projectDir });
            }
        }
        return (_a = tsConfig === null || tsConfig === void 0 ? void 0 : tsConfig.compilerOptions) === null || _a === void 0 ? void 0 : _a[optionKeyPath];
    }
    getProjectFile() {
        const { cwd } = this.core;
        const { project } = this.options;
        return (0, path_1.resolve)(cwd, project || 'tsconfig.json');
    }
    getTsConfig() {
        const { cwd } = this.core;
        this.core.debug('CWD', cwd);
        let { tsConfig } = this.options;
        let tsConfigResult;
        if (typeof tsConfig === 'string') {
            // if ts config is file
            if ((0, fs_extra_1.existsSync)(tsConfig)) {
                tsConfig = (0, fs_extra_1.readFileSync)(tsConfig).toString();
            }
            try {
                tsConfigResult = JSON.parse(tsConfig);
            }
            catch (e) {
                console.log('[midway-bin] tsConfig should be JSON string or Object');
                throw e;
            }
        }
        const projectFile = this.getProjectFile();
        if (!tsConfigResult) {
            if (!(0, fs_extra_1.existsSync)(projectFile)) {
                console.log(`[ Midway ] tsconfig.json not found in ${cwd}\n`);
                throw new Error('tsconfig.json not found');
            }
            try {
                tsConfigResult = JSON.parse((0, fs_extra_1.readFileSync)(projectFile, 'utf-8').toString());
            }
            catch (e) {
                console.log('[ Midway ] Read TsConfig Error', e.message);
                throw e;
            }
        }
        return tsConfigResult;
    }
    async complete() {
        this.core.cli.log('Build Complete!');
    }
}
exports.BuildPlugin = BuildPlugin;
//# sourceMappingURL=index.js.map