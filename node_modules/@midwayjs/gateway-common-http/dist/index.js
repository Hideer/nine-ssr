"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createExpressGateway = exports.createKoaGateway = exports.ExpressGateway = exports.KoaGateway = exports.parseInvokeOptionsByOriginUrl = void 0;
const common_1 = require("./common");
const utils_1 = require("./utils");
var common_2 = require("./common");
Object.defineProperty(exports, "parseInvokeOptionsByOriginUrl", { enumerable: true, get: function () { return common_2.parseInvokeOptionsByOriginUrl; } });
__exportStar(require("./interface"), exports);
class KoaGateway {
    constructor(options) {
        this.options = options;
    }
    async transform(ctx, next, invoke) {
        const { invokeOptions, invokeFun = invoke } = await (0, common_1.parseInvokeOptionsByOriginUrl)(this.options, ctx.request, invoke);
        if (!invokeOptions.functionName) {
            await next();
        }
        else {
            try {
                const result = await invokeFun({
                    functionDir: invokeOptions.functionDir,
                    functionName: invokeOptions.functionName,
                    functionHandler: invokeOptions.functionHandler,
                    data: invokeOptions.data,
                    sourceDir: invokeOptions.sourceDir,
                    incremental: true,
                    verbose: invokeOptions.verbose,
                });
                let data;
                ctx.status = result.statusCode;
                if (result.isBase64Encoded) {
                    // base64 to buffer
                    data = Buffer.from(result.body, 'base64');
                }
                else {
                    try {
                        data = JSON.parse(result.body);
                    }
                    catch (err) {
                        data = result.body;
                    }
                }
                for (const key in result.headers) {
                    ctx.set(key, (0, utils_1.getHeaderValue)(result.headers, key));
                }
                ctx.body = data;
            }
            catch (err) {
                ctx.body = err.stack;
                ctx.status = 500;
            }
            await next();
        }
    }
}
exports.KoaGateway = KoaGateway;
class ExpressGateway {
    constructor(options) {
        this.options = options;
    }
    async transform(req, res, next, invoke) {
        const { invokeOptions, invokeFun = invoke } = await (0, common_1.parseInvokeOptionsByOriginUrl)(this.options, req, invoke);
        if (!invokeOptions.functionName) {
            return next();
        }
        else {
            invokeFun({
                functionDir: invokeOptions.functionDir,
                functionName: invokeOptions.functionName,
                functionHandler: invokeOptions.functionHandler,
                data: invokeOptions.data,
                sourceDir: invokeOptions.sourceDir,
                incremental: true,
                verbose: invokeOptions.verbose,
            })
                .then((result) => {
                let data;
                res.statusCode = result.statusCode;
                if (result.isBase64Encoded) {
                    // base64 to buffer
                    data = Buffer.from(result.body, 'base64');
                }
                else {
                    try {
                        data = JSON.parse(result.body);
                    }
                    catch (err) {
                        data = result.body;
                    }
                }
                for (const key in result.headers) {
                    res.setHeader(key, (0, utils_1.getHeaderValue)(result.headers, key));
                }
                if (res.send) {
                    // express
                    res.send(typeof data === 'number' ? data.toString() : data);
                }
                else {
                    // connect
                    if (typeof data === 'string' || Buffer.isBuffer(data)) {
                        res.end(data);
                    }
                    else {
                        res.end(JSON.stringify(data));
                    }
                }
            })
                .catch(err => {
                next(err);
            });
        }
    }
}
exports.ExpressGateway = ExpressGateway;
const createKoaGateway = (options) => {
    return new KoaGateway(options);
};
exports.createKoaGateway = createKoaGateway;
const createExpressGateway = (options) => {
    return new ExpressGateway(options);
};
exports.createExpressGateway = createExpressGateway;
//# sourceMappingURL=index.js.map