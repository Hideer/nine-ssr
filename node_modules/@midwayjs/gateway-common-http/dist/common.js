"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseInvokeOptionsByOriginUrl = void 0;
const path_to_regexp_1 = require("path-to-regexp");
const qs = require("querystring");
const utils_1 = require("./utils");
const getRawBody = require('raw-body');
const ignoreWildcardFunctionsWhiteList = [];
async function parseInvokeOptionsByOriginUrl(options, req, getFuncList) {
    const ignorePattern = options.ignorePattern;
    const currentUrl = (0, utils_1.getPath)(req);
    const currentMethod = req.method.toLowerCase();
    if (ignorePattern) {
        if (typeof ignorePattern === 'function') {
            if (ignorePattern(req)) {
                return {
                    invokeOptions: {},
                };
            }
        }
        else if (ignorePattern.length) {
            for (const pattern of ignorePattern) {
                if (new RegExp(pattern).test(currentUrl)) {
                    return {
                        invokeOptions: {},
                    };
                }
            }
        }
    }
    const invokeOptions = {};
    invokeOptions.functionDir = options.functionDir;
    invokeOptions.sourceDir = options.sourceDir;
    invokeOptions.verbose = options.verbose;
    const { functionList, invoke } = await getFuncList({
        getFunctionList: true,
        functionDir: options.functionDir,
        sourceDir: options.sourceDir,
        verbose: options.verbose,
    });
    const invokeHTTPData = {};
    // 获取路由
    let urlMatchList = [];
    Object.keys(functionList).forEach(functionName => {
        var _a, _b;
        const functionItem = functionList[functionName] || {};
        const httpEvents = (functionItem.events || []).filter((eventItem) => {
            return eventItem.http || eventItem.apigw;
        });
        for (const event of httpEvents) {
            const eventItem = (event === null || event === void 0 ? void 0 : event.http) || (event === null || event === void 0 ? void 0 : event.apigw);
            if (eventItem) {
                const router = ((_a = eventItem.path) === null || _a === void 0 ? void 0 : _a.replace(/\/\*$/, '/(.*)?')) || '/(.*)?';
                urlMatchList.push({
                    functionName,
                    functionHandler: functionItem.handler,
                    router,
                    originRouter: eventItem.path || '/*',
                    pureRouter: ((_b = eventItem.path) === null || _b === void 0 ? void 0 : _b.replace(/\/\*$/, '/')) || '/',
                    level: router.split('/').length - 1,
                    paramsMatchLevel: router.indexOf('/:') !== -1 ? 1 : 0,
                    method: (eventItem.method ? [].concat(eventItem.method) : []).map(method => {
                        return method.toLowerCase();
                    }),
                });
            }
        }
    });
    // 1. 绝对路径规则优先级最高如 /ab/cb/e
    // 2. 星号只能出现最后且必须在/后面，如 /ab/cb/**
    // 3. 如果绝对路径和通配都能匹配一个路径时，绝对规则优先级高
    // 4. 有多个通配能匹配一个路径时，最长的规则匹配，如 /ab/** 和 /ab/cd/** 在匹配 /ab/cd/f 时命中 /ab/cd/**
    // 5. 如果 / 与 /* 都能匹配 / ,但 / 的优先级高于 /*
    urlMatchList = urlMatchList.sort((handlerA, handlerB) => {
        if (handlerA.level === handlerB.level) {
            if (handlerA.pureRouter === handlerB.pureRouter) {
                return handlerA.router.length - handlerB.router.length;
            }
            if (handlerA.paramsMatchLevel === handlerB.paramsMatchLevel) {
                return handlerB.pureRouter.length - handlerA.pureRouter.length;
            }
            return handlerA.paramsMatchLevel - handlerB.paramsMatchLevel;
        }
        return handlerB.level - handlerA.level;
    });
    let matchRes;
    const functionItem = urlMatchList.find(item => {
        var _a;
        matchRes = (0, path_to_regexp_1.match)(item.router)(currentUrl);
        if (matchRes) {
            if (item.method.length && item.method.indexOf(currentMethod) === -1) {
                return false;
            }
            // 如果不在白名单内，并且是需要被忽略的函数，则跳过函数处理
            if (!ignoreWildcardFunctionsWhiteList.includes(currentUrl) &&
                ((_a = options.ignoreWildcardFunctions) === null || _a === void 0 ? void 0 : _a.includes(item.functionName))) {
                // 中后台 webpack 的特殊处理，忽略特定函数的通配逻辑
                return currentUrl.indexOf(item.originRouter) !== -1;
            }
            return true;
        }
    });
    if (functionItem === null || functionItem === void 0 ? void 0 : functionItem.functionName) {
        // 匹配到了函数
        invokeOptions.functionName = functionItem.functionName;
        invokeOptions.functionHandler = functionItem.functionHandler;
        // 构造参数
        invokeHTTPData.headers = req.headers;
        if (req.body) {
            const contentType = invokeHTTPData.headers['content-type'] || '';
            if (contentType.startsWith('application/x-www-form-urlencoded')) {
                invokeHTTPData.body = qs.stringify(req.body);
            }
            else if (contentType.startsWith('multipart/form-data')) {
                if (req.pipe) {
                    req.body = await getRawBody(req);
                }
                invokeHTTPData.body = req.body;
            }
            else if (contentType.startsWith('application/json') ||
                typeof req.body !== 'string') {
                invokeHTTPData.body = JSON.stringify(req.body);
            }
        }
        else {
            invokeHTTPData.body = undefined;
        }
        invokeHTTPData.method = req.method;
        invokeHTTPData.pathParameters = matchRes.params || {};
        invokeHTTPData.path = currentUrl;
        invokeHTTPData.url = req.url;
        invokeHTTPData.query = (0, utils_1.getQuery)(req);
        invokeHTTPData.base64Encoded = false;
        invokeOptions.data = [invokeHTTPData];
    }
    return {
        invokeOptions,
        invokeFun: invoke,
    };
}
exports.parseInvokeOptionsByOriginUrl = parseInvokeOptionsByOriginUrl;
//# sourceMappingURL=common.js.map