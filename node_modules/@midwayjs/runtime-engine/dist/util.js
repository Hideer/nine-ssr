"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fileExists = exports.getHandlerMeta = exports.getHandlerMethod = exports.completeAssign = exports.isDebug = exports.asyncWrapper = exports.isTsEnv = void 0;
const fs_1 = require("mz/fs");
const path_1 = require("path");
const isTsEnv = () => {
    const TS_MODE_PROCESS_FLAG = process.env.MIDWAY_TS_MODE;
    if ('false' === TS_MODE_PROCESS_FLAG) {
        return false;
    }
    // eslint-disable-next-line node/no-deprecated-api
    return TS_MODE_PROCESS_FLAG === 'true' || !!require.extensions['.ts'];
};
exports.isTsEnv = isTsEnv;
const asyncWrapper = handler => {
    return (...args) => {
        if (typeof args[args.length - 1] === 'function') {
            const callback = args.pop();
            if (handler.constructor.name !== 'AsyncFunction') {
                const err = new TypeError('Must be an AsyncFunction');
                return callback(err);
            }
            // 其他事件场景
            return handler.apply(handler, args).then(result => {
                callback(null, result);
            }, err => {
                callback(err);
            });
        }
        else {
            return handler.apply(handler, args);
        }
    };
};
exports.asyncWrapper = asyncWrapper;
const isDebug = () => {
    return process.env['FAAS_DEBUG'] === 'true';
};
exports.isDebug = isDebug;
/**
 * This is an assign function that copies full descriptors
 * @param {Object} target 合并的目标对象
 * @param {Object} sources 合并的原对象
 * @return {*} 合并的结果对象
 */
const completeAssign = function (...sources) {
    const target = sources.shift();
    sources.forEach(source => {
        const descriptors = Object.keys(source).reduce((descriptors, key) => {
            if (Object.getOwnPropertyDescriptor(target, key)) {
                // delete target[key];
            }
            descriptors[key] = Object.getOwnPropertyDescriptor(source, key);
            return descriptors;
        }, {});
        // by default, Object.assign copies enumerable Symbols too
        /* istanbul ignore next */
        Object.getOwnPropertySymbols(source).forEach(sym => {
            const descriptor = Object.getOwnPropertyDescriptor(source, sym);
            if (descriptor.enumerable) {
                descriptors[sym] = descriptor;
            }
        });
        // 在 copy 属性时不执行 get/set 方法
        for (const name in descriptors) {
            if (Object.getOwnPropertyDescriptor(target, name)) {
                // console.debug('Property: "%s" already exists, will be override', name);
            }
            if (/^(before|after)\w+/.test(name) &&
                typeof descriptors[name].value === 'function') {
                if (!target['handlerStore']) {
                    Object.defineProperty(target, 'handlerStore', {
                        value: new Map(),
                    });
                }
                if (!target['handlerStore'].has(name + 'Handler')) {
                    target['handlerStore'].set(name + 'Handler', []);
                }
                target['handlerStore']
                    .get(name + 'Handler')
                    .push(descriptors[name].value);
            }
            else {
                Object.defineProperty(target, name, descriptors[name]);
            }
        }
    });
    return target;
};
exports.completeAssign = completeAssign;
/**
 * get handler function with file path and method name
 * @param filePath
 * @param handler
 */
const getHandlerMethod = (filePath, handler) => {
    const mod = require(filePath);
    if (mod && mod[handler]) {
        return mod[handler].bind(mod);
    }
};
exports.getHandlerMethod = getHandlerMethod;
/**
 * parse handler file name and method name
 * @param handlerName
 */
const getHandlerMeta = (handlerName) => {
    if (/\./.test(handlerName)) {
        const meta = handlerName.split('.');
        return { fileName: meta[0], handler: meta[1] };
    }
    else {
        // error
    }
};
exports.getHandlerMeta = getHandlerMeta;
const fileExists = (entryDir, fileName) => {
    const jsFile = (0, path_1.join)(entryDir, fileName + '.js');
    const tsFile = (0, path_1.join)(entryDir, fileName + '.ts');
    if ((0, exports.isTsEnv)()) {
        return (0, fs_1.exists)(tsFile);
    }
    else {
        /* istanbul ignore next */
        return (0, fs_1.exists)(jsFile);
    }
};
exports.fileExists = fileExists;
//# sourceMappingURL=util.js.map