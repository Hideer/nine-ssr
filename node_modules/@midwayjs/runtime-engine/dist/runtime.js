"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerlessBaseRuntime = void 0;
const events_1 = require("events");
const path_1 = require("path");
const parser_1 = require("./lib/parser");
const debug_1 = require("./lib/debug");
const loggerFactory_1 = require("./lib/loggerFactory");
const util_1 = require("./util");
const performance_1 = require("./lib/performance");
class ServerlessBaseRuntime extends events_1.EventEmitter {
    constructor() {
        super();
        this.debugLogger = new debug_1.DebugLogger('base_runtime');
        this.eventHandlers = [];
        this.handlerStore = new Map();
        this.logger = null;
        this.options = {};
        this.propertyParser = this.createEnvParser();
        this.loggerFactory = this.createLoggerFactory();
        this.logger = this.loggerFactory.createLogger();
    }
    init(contextExtensions) {
        this.contextExtensions = contextExtensions;
    }
    async runtimeStart(eventExtensions) {
        await this.handlerInvokerWrapper('beforeRuntimeStartHandler', [this]);
        for (const eventExtension of eventExtensions) {
            const funEvent = await eventExtension(this);
            if (funEvent) {
                this.eventHandlers.push(funEvent);
            }
        }
        await this.handlerInvokerWrapper('afterRuntimeStartHandler', [this]);
    }
    async functionStart() {
        await this.handlerInvokerWrapper('beforeFunctionStartHandler', [this]);
        // invoke init handler
        await this.invokeInitHandler({
            baseDir: this.propertyParser.getEntryDir(),
        });
        await this.handlerInvokerWrapper('afterFunctionStartHandler', [this]);
    }
    async getContext(event, newArgs) {
        return this.contextExtensions.reduce((promiseCtx, contextExtension) => promiseCtx.then(ctx => {
            return Promise.resolve(contextExtension(ctx, this)).then((realCtx) => realCtx || ctx);
        }), Promise.resolve(this.createFunctionContext(event, newArgs)));
    }
    async emitHandler(funEvent, args) {
        let newArgs = args;
        if (funEvent.transformInvokeArgs) {
            newArgs = funEvent.transformInvokeArgs.call(funEvent, args) || [];
        }
        const context = await this.getContext(funEvent, newArgs);
        try {
            await this.handlerInvokerWrapper('beforeInvokeHandler', [
                context,
                args,
                funEvent.meta,
            ]);
            const result = await this.invokeDataHandler(context, ...newArgs);
            await this.handlerInvokerWrapper('afterInvokeHandler', [
                null,
                result,
                context,
            ]);
            return result;
        }
        catch (err) {
            await this.handlerInvokerWrapper('afterInvokeHandler', [
                err,
                null,
                context,
            ]);
            if (context.logger && typeof context.logger.error === 'function') {
                context.logger.error(err);
            }
            err.message = `${err.message}, \nStack: ${err.stack}`;
            throw err;
        }
    }
    async close() {
        await this.handlerInvokerWrapper('beforeCloseHandler', [this]);
        if (this.logger) {
            this.logger.close();
        }
    }
    createEnvParser() {
        return new parser_1.EnvPropertyParser();
    }
    createLogger(options) {
        return console;
    }
    createLoggerFactory() {
        const homeDir = this.getProperty('HOME');
        return new loggerFactory_1.BaseLoggerFactory(homeDir || process.cwd(), this.propertyParser);
    }
    async invokeInitHandler(...args) {
        let func;
        const entryDir = this.propertyParser.getEntryDir();
        const { fileName, handler } = (0, util_1.getHandlerMeta)(this.propertyParser.getInitHandler());
        if (await (0, util_1.fileExists)(entryDir, fileName)) {
            try {
                func = (0, util_1.getHandlerMethod)((0, path_1.join)(entryDir, fileName), handler);
                this.debugLogger.log('invoke init handler');
                if (func) {
                    this.debugLogger.log('found handler and call');
                    return await new Promise((resolve, reject) => {
                        const timer = setTimeout(() => {
                            // TODO error stack
                            reject(new Error('timeout'));
                        }, Number(this.propertyParser.getInitTimeout()));
                        Promise.resolve(func.call(this, this, ...args))
                            .then(res => {
                            clearTimeout(timer);
                            resolve(res);
                        })
                            .catch(err => {
                            clearTimeout(timer);
                            reject(err);
                        });
                    });
                }
            }
            catch (err) {
                err.message = `function init error with: ${err.message}`;
                throw err;
            }
        }
        else {
            this.debugLogger.log('no init handler found');
        }
    }
    async invokeDataHandler(...args) {
        const entryDir = this.propertyParser.getEntryDir();
        const { fileName, handler } = (0, util_1.getHandlerMeta)(this.propertyParser.getFunctionHandler());
        let error = new Error(`invoke handler not found: ${fileName}.${handler}`);
        try {
            let func;
            const flag = await (0, util_1.fileExists)(entryDir, fileName);
            if (flag) {
                this.debugLogger.log('invoke data handler');
                func = (0, util_1.getHandlerMethod)((0, path_1.join)(entryDir, fileName), handler);
            }
            if (flag && func) {
                this.debugLogger.log('found handler and call');
                return func.apply(this, args);
            }
            else {
                return this.defaultInvokeHandler(...args);
            }
        }
        catch (err) {
            error = err;
            this.logger.error(err);
        }
        return Promise.reject(error);
    }
    async triggerRoute(payload) {
        for (const event of this.eventHandlers) {
            if (event.match(payload)) {
                return event;
            }
        }
        throw new Error('trigger not found');
    }
    async invoke(payload) {
        const funEvent = await this.triggerRoute(payload);
        return new Promise((resolve, reject) => {
            const timer = setTimeout(() => {
                reject(new Error(`function invoke timeout: ${JSON.stringify(payload)}`));
            }, Number(this.propertyParser.getFuncTimeout()));
            this.emitHandler(funEvent, payload)
                .then(res => {
                clearTimeout(timer);
                resolve(res);
            })
                .catch(err => {
                clearTimeout(timer);
                reject(err);
            });
        });
    }
    async defaultInvokeHandler(...args) {
        const { fileName, handler } = (0, util_1.getHandlerMeta)(this.propertyParser.getFunctionHandler());
        throw new Error(`handler not found: ${fileName}.${handler}, please check your f.yml`);
    }
    createFunctionContext(event, ...args) {
        if (event.getContext) {
            return event.getContext(args);
        }
        return {};
    }
    getProperty(propertyKey) {
        return this.propertyParser.getProperty(propertyKey);
    }
    getPropertyParser() {
        return this.propertyParser;
    }
    getContextExtensions() {
        return this.contextExtensions;
    }
    async handlerInvokerWrapper(handlerKey, args) {
        performance_1.default.mark(`midway-faas:${handlerKey}:start`);
        if (this.handlerStore.has(handlerKey)) {
            const handlers = this.handlerStore.get(handlerKey);
            this.debugLogger.log(`${handlerKey} exec, task = ${handlers.length}`);
            for (const handler of handlers) {
                await handler.apply(this, args);
            }
        }
        performance_1.default.mark(`midway-faas:${handlerKey}:end`);
    }
    setOptions(options) {
        this.options = options;
    }
    get isAppMode() {
        return !!this.options.isAppMode;
    }
    getRuntimeConfig() {
        var _a;
        return ((_a = this.options) === null || _a === void 0 ? void 0 : _a.runtimeConfig) || {};
    }
    /**
     * get function name in runtime
     */
    getFunctionName() {
        return process.env.MIDWAY_SERVERLESS_FUNCTION_NAME || '';
    }
    /**
     * get function service/group in runtime
     */
    getFunctionServiceName() {
        return process.env.MIDWAY_SERVERLESS_SERVICE_NAME || '';
    }
}
exports.ServerlessBaseRuntime = ServerlessBaseRuntime;
//# sourceMappingURL=runtime.js.map