import { LoggerOptions } from 'egg-logger';
export declare type ContextExtensionHandler = (ctx: any, runtime: Runtime) => Promise<void>;
export declare type HealthExtensionHandler = (ctx: any, runtime: Runtime) => Promise<void>;
export declare type EventExtensionHandler = (runtime: Runtime) => Promise<FunctionEvent>;
export declare type handlerWrapper = (...args: any[]) => any;
export declare const FAAS_ARGS_KEY = "FAAS_ARGS";
export interface RuntimeEngine {
    add(engineHandler: (engine: RuntimeEngine) => void): any;
    addBaseRuntime(baseRuntime: Runtime): any;
    addRuntimeExtension(ext: RuntimeExtension): RuntimeEngine;
    addContextExtension(contextExtensionHandler: ContextExtensionHandler): RuntimeEngine;
    addHealthExtension(healthExtensionHandler: HealthExtensionHandler): RuntimeEngine;
    addEventExtension(eventExtensionHandler: EventExtensionHandler): RuntimeEngine;
    ready(): any;
    close(): any;
    getCurrentRuntime(): Runtime;
}
export interface RuntimeExtension {
    beforeRuntimeStart?(runtime: Runtime): any;
    afterRuntimeStart?(runtime: Runtime): any;
    beforeFunctionStart?(runtime: Runtime): any;
    afterFunctionStart?(runtime: Runtime): any;
    beforeClose?(runtime: Runtime): any;
    createLogger?(filename?: any, options?: any): any;
    createEnvParser?(): PropertyParser<string>;
    beforeInvoke?(functionContext: any, args?: any, meta?: any): any;
    afterInvoke?(err: Error, result: any, context?: any): any;
    defaultInvokeHandler?(...args: any[]): any;
}
export interface Runtime extends RuntimeExtension {
    debugLogger: any;
    logger: any;
    eventHandlers: FunctionEvent[];
    isAppMode: boolean;
    init(contextExtensions: ContextExtensionHandler[]): any;
    runtimeStart(eventExtensions: EventExtensionHandler[]): any;
    functionStart(): any;
    close(): any;
    getProperty(propertyKey: string): any;
    getPropertyParser(): PropertyParser<string>;
    invokeInitHandler(...args: any[]): any;
    invokeDataHandler(...args: any[]): any;
    invoke(...payload: any[]): Promise<any>;
    triggerRoute(...payload: any[]): Promise<FunctionEvent>;
    getContextExtensions(): ContextExtensionHandler[];
    setOptions(RuntimeOptions: any): void;
    getFunctionName(): string;
    getFunctionServiceName(): string;
    getRuntimeConfig(): any;
}
export interface LightRuntime extends Runtime {
    invokeHandlerWrapper(context: any, invokeHandler: any): any;
    asyncEvent(handler: handlerWrapper): (...args: any[]) => void;
    getApplication(): any;
}
export interface IServerlessLogger {
    log?(msg: any, ...args: any[]): void;
    info(msg: any, ...args: any[]): void;
    debug(msg: any, ...args: any[]): void;
    error(msg: any, ...args: any[]): void;
    warn(msg: any, ...args: any[]): void;
    write?(msg: string): void;
}
export interface PropertyParser<T> {
    setProperty(key: string, value: any): any;
    getProperty(key: string, defaultValue?: any): any;
    getInitTimeout(): T;
    getInitHandler(): T;
    getFuncTimeout(): T;
    getFunctionHandler(): T;
    getFunctionRuntime(): T;
    getEntryDir(): T;
    getTriggerType(): T;
    getFunctionLayer(): T;
    getLoggerLevel(): T;
}
export interface ServerlessLoggerOptions extends LoggerOptions {
    file?: string;
    eol?: string;
    formatter?: any;
}
export interface LoggerFactory {
    createLogger(options?: any): any;
}
export interface FunctionEvent {
    type: string;
    meta: object;
    match(...args: any[]): boolean;
    run?(...args: any[]): Promise<any>;
    getContext?(...args: any[]): Promise<any>;
    transformInvokeArgs?(...args: any[]): any[];
}
export interface Bootstrap {
    start(runtime: any): any;
    close(): any;
    getRuntime(): any;
    getRuntimeEngine(): any;
}
export interface BootstrapOptions {
    layers?: any[];
    runtime?: Runtime;
    initContext?: any;
    isAppMode?: boolean;
    runtimeConfig?: any;
}
//# sourceMappingURL=interface.d.ts.map