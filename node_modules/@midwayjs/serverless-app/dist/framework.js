"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Framework = void 0;
const core_1 = require("@midwayjs/core");
const platform_1 = require("./platform");
const express = require("express");
const utils_1 = require("./utils");
const start_1 = require("./start");
const fs_1 = require("fs");
const path_1 = require("path");
const bodyParser = require("body-parser");
const serverless_spec_builder_1 = require("@midwayjs/serverless-spec-builder");
const gateway_common_http_1 = require("@midwayjs/gateway-common-http");
class Framework {
    configure(options = {}) {
        this.configurationOptions = options;
        return this;
    }
    async stop() {
        var _a;
        if ((_a = this.server) === null || _a === void 0 ? void 0 : _a.close) {
            this.server.close();
        }
        if (this.innerBootStarter) {
            await this.innerBootStarter.stop();
        }
        if (this.runtime) {
            await this.runtime.close();
        }
    }
    getApplicationContext() {
        return this.innerApp.getApplicationContext();
    }
    getConfiguration(key) {
        return this.innerApp.getConfig(key);
    }
    getCurrentEnvironment() {
        return this.innerApp.getEnv();
    }
    getAppDir() {
        return this.innerApp.getAppDir();
    }
    getLogger(name) {
        return this.innerApp.getLogger(name);
    }
    getBaseDir() {
        return this.innerApp.getBaseDir();
    }
    getCoreLogger() {
        return this.innerApp.coreLogger;
    }
    createLogger(name, options) {
        return this.innerApp.createLogger(name, options);
    }
    getProjectName() {
        return this.innerApp.getProjectName();
    }
    getDefaultContextLoggerClass() {
        return this.innerFramework.getDefaultContextLoggerClass();
    }
    async applicationInitialize(options) { }
    getFrameworkName() {
        return 'midway:serverless:app';
    }
    getFrameworkType() {
        return core_1.MidwayFrameworkType.SERVERLESS_APP;
    }
    getApplication() {
        if (!this.proxyApp) {
            this.proxyApp = new Proxy(this.app, {
                get: (target, key) => {
                    if (target[key]) {
                        return target[key];
                    }
                    if (this[key]) {
                        return this[key];
                    }
                },
            });
        }
        return this.proxyApp;
    }
    getServer() {
        return this.server;
    }
    getStarterName() {
        var _a, _b;
        const starter = (_b = (_a = this.spec) === null || _a === void 0 ? void 0 : _a.provider) === null || _b === void 0 ? void 0 : _b.starterModule;
        if (starter) {
            return require.resolve(starter);
        }
        const platform = this.getPlatform();
        const starterModList = platform_1.StarterMap[platform];
        if (!starterModList || !starterModList.length) {
            throw new Error(`Current provider '${platform}' not support(no starter)`);
        }
        for (const mod of starterModList) {
            try {
                return require.resolve(mod);
            }
            catch (_c) {
                // continue
            }
        }
        throw new Error(`Platform starter '${starterModList[starterModList.length - 1]}' not found`);
    }
    getTriggerMap() {
        var _a, _b;
        const trigger = (_b = (_a = this.spec) === null || _a === void 0 ? void 0 : _a.provider) === null || _b === void 0 ? void 0 : _b.triggerModule;
        if (trigger) {
            return require(trigger);
        }
        const platform = this.getPlatform();
        const triggerModList = platform_1.TriggerMap[platform];
        if (!triggerModList || !triggerModList.length) {
            throw new Error(`Current provider '${platform}' not support(no trigger)`);
        }
        for (const mod of triggerModList) {
            try {
                return require(mod);
            }
            catch (_c) {
                // continue
            }
        }
        throw new Error(`Platform trigger '${triggerModList[triggerModList.length - 1]}' not found`);
    }
    async getServerlessInstance(cls) {
        // 如何传initializeContext
        const context = await new Promise(resolve => {
            var _a;
            this.runtime.asyncEvent(async (ctx) => {
                resolve(this.innerFramework.getContext(ctx));
            })({}, (_a = this.configurationOptions.initContext) !== null && _a !== void 0 ? _a : {});
        });
        return context.requestContext.getAsync(cls);
    }
    getPlatform() {
        var _a, _b;
        const provider = (_b = (_a = this.spec) === null || _a === void 0 ? void 0 : _a.provider) === null || _b === void 0 ? void 0 : _b.name;
        if (provider) {
            if (provider === 'fc' || provider === 'aliyun') {
                return 'aliyun';
            }
            else if (provider === 'scf' || provider === 'tencent') {
                return 'tencent';
            }
        }
        return provider;
    }
    async initialize(options) {
        var _a, _b, _c, _d;
        this.bootstrapOptions = options;
        this.getFaaSSpec();
        this.app = express();
        const { appDir, baseDir } = options;
        const faasModule = '@midwayjs/faas';
        const faasModulePath = (_a = process.env.MIDWAY_FAAS_PATH) !== null && _a !== void 0 ? _a : (0, utils_1.findNpmModule)(appDir, faasModule);
        if (!faasModulePath) {
            throw new Error(`Module '${faasModule}' not found`);
        }
        const starterName = this.getStarterName();
        const usageFaaSModule = this.getFaaSModule();
        let usageFaasModulePath = faasModulePath;
        if (usageFaaSModule !== faasModule) {
            usageFaasModulePath = (0, utils_1.findNpmModule)(appDir, usageFaaSModule);
            if (!usageFaasModulePath) {
                throw new Error(`Module '${usageFaasModulePath}' not found`);
            }
        }
        // 分析项目结构
        const currentBaseDir = baseDir;
        const layers = this.getLayers();
        const { Framework } = require(usageFaasModulePath);
        const startResult = await (0, start_1.start2)({
            appDir,
            baseDir: currentBaseDir,
            framework: Framework,
            layers: layers,
            starter: require(starterName),
            initializeContext: (_b = this.configurationOptions) === null || _b === void 0 ? void 0 : _b.initContext,
        });
        this.innerFramework = startResult.framework;
        this.innerBootStarter = startResult.innerBootStarter;
        this.runtime = startResult.runtime;
        this.innerApp = startResult.framework.getApplication();
        this.invokeFun = startResult.invoke;
        const funcSpec = await startResult.getFunctionsFromDecorator();
        if (!this.spec.functions) {
            this.spec.functions = {};
        }
        Object.assign(this.spec.functions, funcSpec);
        this.app.getServerlessInstance = this.getServerlessInstance.bind(this);
        this.app.use(bodyParser.urlencoded({
            extended: false,
            limit: (_c = this.configurationOptions.bodyParserLimit) !== null && _c !== void 0 ? _c : '2mb',
        }));
        this.app.use(bodyParser.json({
            limit: (_d = this.configurationOptions.bodyParserLimit) !== null && _d !== void 0 ? _d : '2mb',
        }));
        this.app.use(this.faasInvokeMiddleware.bind(this));
        this.app.use((req, res) => {
            res.statusCode = 404;
            res.send((0, utils_1.output404)(req.path, this.spec.functions));
        });
        if (process.env.IN_CHILD_PROCESS) {
            this.listenMessage();
        }
    }
    async faasInvokeMiddleware(req, res, next) {
        var _a;
        const { appDir } = this.bootstrapOptions;
        const platform = this.getPlatform();
        const triggerMap = this.getTriggerMap();
        // for ali fc
        if (platform === 'aliyun') {
            if (!((_a = this.spec.experimentalFeatures) === null || _a === void 0 ? void 0 : _a.forceFCCORS)) {
                const origin = req.get('origin');
                if (origin) {
                    res.setHeader('Access-Control-Allow-Origin', origin);
                    res.setHeader('Access-Control-Allow-Credentials', 'true');
                    res.setHeader('Access-Control-Allow-Methods', '*');
                    res.setHeader('Access-Control-Allow-Headers', '*');
                    if (req.method.toLowerCase() === 'options') {
                        res.setHeader('Access-Control-Allow-Methods', req.get('Access-Control-Request-Method') || '*');
                        res.setHeader('Access-Control-Allow-Headers', req.get('Access-Control-Request-Headers') || '*');
                        res.send('');
                        return;
                    }
                }
            }
        }
        const gateway = (0, gateway_common_http_1.createExpressGateway)({
            functionDir: appDir,
        });
        gateway.transform(req, res, next, async () => {
            return {
                functionList: this.spec.functions,
                invoke: async (args) => {
                    const trigger = [new triggerMap.http(...args.data)];
                    let newArgs = trigger;
                    let callBackTrigger;
                    if ((newArgs === null || newArgs === void 0 ? void 0 : newArgs[0]) && typeof newArgs[0].toArgs === 'function') {
                        callBackTrigger = trigger[0];
                        newArgs = await trigger[0].toArgs();
                    }
                    const result = await new Promise((resolve, reject) => {
                        if (callBackTrigger === null || callBackTrigger === void 0 ? void 0 : callBackTrigger.useCallback) {
                            // 这个地方 callback 得调用 resolve
                            const cb = callBackTrigger.createCallback((err, result) => {
                                if (err) {
                                    return reject(err);
                                }
                                return resolve(result);
                            });
                            newArgs.push(cb);
                        }
                        Promise.resolve(this.invokeFun(args.functionHandler, newArgs)).then(resolve, reject);
                    });
                    if (callBackTrigger === null || callBackTrigger === void 0 ? void 0 : callBackTrigger.close) {
                        await callBackTrigger.close();
                    }
                    return result;
                },
            };
        });
    }
    getFaaSModule() {
        return process.env.DEV_MIDWAY_FAAS_MODULE || '@midwayjs/faas';
    }
    getFaasStarterName() {
        return 'FaaSStarter';
    }
    getFaaSSpec() {
        const { appDir } = this.bootstrapOptions;
        const syamlPath = (0, path_1.resolve)(appDir, 's.yaml');
        if ((0, fs_1.existsSync)(syamlPath)) {
            const file = (0, serverless_spec_builder_1.parse)(syamlPath, (0, fs_1.readFileSync)(syamlPath).toString());
            if (file === null || file === void 0 ? void 0 : file.services) {
                const allApps = Object.keys(file.services);
                if (allApps.length) {
                    this.spec = file.services[allApps[0]].props;
                }
            }
        }
        else {
            const specFileInfo = (0, serverless_spec_builder_1.getSpecFile)(appDir);
            this.spec = (0, serverless_spec_builder_1.loadSpec)(appDir, specFileInfo);
        }
    }
    async run() {
        if (this.configurationOptions.port) {
            if (this.configurationOptions.ssl) {
                this.server = require('https').createServer({
                    key: (0, fs_1.readFileSync)((0, path_1.join)(__dirname, '../ssl/ssl.key'), 'utf8'),
                    cert: (0, fs_1.readFileSync)((0, path_1.join)(__dirname, '../ssl/ssl.pem'), 'utf8'),
                }, this.app);
            }
            else {
                this.server = require('http').createServer(this.app);
            }
            await new Promise(resolve => {
                this.server.listen(this.configurationOptions.port, () => {
                    resolve();
                });
            });
        }
    }
    listenMessage() {
        process.on('message', async (msg) => {
            if (!msg || !msg.type) {
                return;
            }
            const type = msg.type;
            let data;
            switch (type) {
                case 'functions':
                    data = this.spec.functions;
                    break;
            }
            process.send({ type: 'dev:' + type, data, id: msg.id });
        });
    }
    getLayers() {
        var _a;
        const specLayers = [];
        if ((_a = this.spec) === null || _a === void 0 ? void 0 : _a.layers) {
            Object.keys(this.spec.layers).forEach(layerName => {
                const info = this.spec.layers[layerName];
                if (!(info === null || info === void 0 ? void 0 : info.path)) {
                    return;
                }
                const [type, path] = info.path.split(':');
                if (type === 'npm') {
                    const layer = require(path);
                    specLayers.push(layer);
                }
            });
        }
        return specLayers;
    }
}
exports.Framework = Framework;
//# sourceMappingURL=framework.js.map