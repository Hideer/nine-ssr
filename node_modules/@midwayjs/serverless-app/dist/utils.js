"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.analysisDecorator = exports.output404 = exports.findNpmModule = void 0;
const path_1 = require("path");
const fs_1 = require("fs");
const findNpmModule = (cwd, modName) => {
    const modPath = (0, path_1.join)(cwd, 'node_modules', modName);
    if ((0, fs_1.existsSync)(modPath)) {
        return modPath;
    }
    const parentCwd = (0, path_1.join)(cwd, '../');
    if (parentCwd !== cwd) {
        return (0, exports.findNpmModule)(parentCwd, modName);
    }
};
exports.findNpmModule = findNpmModule;
const output404 = (path, functionsMap) => {
    const allPathMap = {};
    Object.keys(functionsMap || {}).forEach(functionName => {
        const funcItem = functionsMap[functionName];
        if (!funcItem.events || !funcItem.events.length) {
            return;
        }
        funcItem.events.forEach(event => {
            if (!event) {
                return;
            }
            const http = event.http || event.apigw;
            if (http) {
                allPathMap[http.path || '/'] = {
                    method: [].concat(http.method),
                    functionName,
                };
            }
        });
    });
    const allPath = Object.keys(allPathMap);
    return `
    <div style="padding: 48px 24px 0 24px;font-size: 24px;color: #333;line-height: 24px;">404</div>
    <div style="padding: 0 24px;font-size: 14px;color: #666;line-height: 48px;">path '${path}' not found</div>
    ${process.env.NODE_ENV === 'local' && allPath.length
        ? `<div style="padding: 24px;font-size: 13px;line-height: 18px;">
      <div>You can visit:</div>
      ${allPath
            .map(path => {
            return `<a href="${path}">${path}</a>`;
        })
            .join('<br />')}</div>`
        : ''}
    <div style="border-top: 1px solid #eee;padding: 24px;font-size: 12px;color: #ccc;line-height: 36px;">© Midwayjs</div>
  `;
};
exports.output404 = output404;
// 分析装饰器上面的函数信息
const analysisDecorator = async (cwd) => {
    const midwayCoreMod = (0, exports.findNpmModule)(cwd, '@midwayjs/core');
    const { ServerlessTriggerCollector } = require(midwayCoreMod);
    const collector = new ServerlessTriggerCollector();
    const result = await collector.getFunctionList();
    const allFunc = {};
    if (Array.isArray(result)) {
        result.forEach(func => {
            const handler = func.funcHandlerName;
            if (!handler) {
                return;
            }
            if (!func.functionTriggerMetadata) {
                func.functionTriggerMetadata = {};
            }
            const funcName = func.functionTriggerMetadata.functionName ||
                func.functionName ||
                handler.replace(/[^\w]/g, '-');
            if (!allFunc[funcName]) {
                allFunc[funcName] = {
                    handler,
                    events: [],
                };
            }
            if (!allFunc[funcName].events) {
                allFunc[funcName].events = [];
            }
            if (!allFunc[funcName].handler) {
                allFunc[funcName].handler = handler;
            }
            const trigger = func.functionTriggerName;
            let isAddToTrigger = false;
            const { path, method } = func.functionTriggerMetadata;
            func.functionTriggerMetadata.method = [].concat(method || []);
            // 避免重复路径创建多个trigger
            const httpTrigger = path &&
                allFunc[funcName].events.find(event => {
                    var _a, _b;
                    return ((_a = event.http) === null || _a === void 0 ? void 0 : _a.path) === path || ((_b = event.apigw) === null || _b === void 0 ? void 0 : _b.path) === path;
                });
            if (httpTrigger) {
                httpTrigger.http.method = [].concat(httpTrigger.http.method || []);
                if (method) {
                    [].concat(method).forEach(methodItem => {
                        if (!httpTrigger.http.method.includes(methodItem)) {
                            httpTrigger.http.method.push(methodItem);
                        }
                    });
                }
                isAddToTrigger = true;
            }
            if (!isAddToTrigger) {
                const triggerIsBoolean = !Object.keys(func.functionTriggerMetadata)
                    .length;
                allFunc[funcName].events.push({
                    [trigger]: triggerIsBoolean ? true : func.functionTriggerMetadata,
                });
            }
        });
    }
    return allFunc;
};
exports.analysisDecorator = analysisDecorator;
//# sourceMappingURL=utils.js.map