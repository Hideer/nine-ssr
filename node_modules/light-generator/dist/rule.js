"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.replaceRule = exports.ignoreRule = void 0;
const fse = __importStar(require("fs-extra"));
const path_1 = require("path");
const minimatch_1 = __importDefault(require("minimatch"));
const debug = require('util').debuglog('generator');
/**
 * 移除文件下划线
 * @param currentFilePath
 */
const ignoreRule = async (currentFilePath, copyRuleOptions) => {
    const filename = path_1.basename(copyRuleOptions.targetRelativeFile);
    if (/^_/.test(filename)) {
        if (copyRuleOptions.filenameMapping.has(currentFilePath)) {
            // 如果名字被修改过，拿新的名字去替换
            const newFilePath = copyRuleOptions.filenameMapping.get(currentFilePath);
            const newName = path_1.join(copyRuleOptions.targetDir, path_1.relative(copyRuleOptions.targetDir, newFilePath).replace('_', ''));
            await fse.rename(newFilePath, newName);
            copyRuleOptions.filenameMapping.set(currentFilePath, newName);
            debug(` * remove _ => ${newName}`);
        }
        else {
            const newName = path_1.join(copyRuleOptions.targetDir, copyRuleOptions.targetRelativeFile.replace('_', ''));
            await fse.rename(currentFilePath, newName);
            copyRuleOptions.filenameMapping.set(currentFilePath, newName);
            debug(` * remove _ => ${newName}`);
        }
    }
};
exports.ignoreRule = ignoreRule;
const pattern = /\{\{(\w*[:]*[=]*\w+)\}\}(?!})/g;
/**
 * 替换文本内容包含 {{}} 的字符串模板
 * @param currentFilePath
 * @param copyRuleOptions
 */
const replaceRule = async (currentFilePath, copyRuleOptions) => {
    const replaceArgs = copyRuleOptions.replaceParameter || {};
    if (includeReplaceContent(copyRuleOptions.templateConfig.replaceFile, copyRuleOptions.targetRelativeFile)) {
        // 如果当前文件在替换列表中，则进行内容替换
        const contents = fse
            .readFileSync(currentFilePath, 'utf-8')
            .replace(pattern, (match, key, value) => {
            debug(` * replace content key => ${key}`);
            return replaceArgs[key] || match;
        });
        await fse.writeFile(currentFilePath, contents);
    }
    // 如果文件名需要替换
    if (new RegExp(pattern).test(currentFilePath)) {
        const newFilePath = currentFilePath.replace(pattern, (match, key, value) => {
            debug(` * replace filename key => ${key}`);
            return replaceArgs[key];
        });
        await fse.move(currentFilePath, newFilePath);
        // 一定要更新文件名，不然后续处理找不到
        copyRuleOptions.filenameMapping.set(currentFilePath, newFilePath);
    }
};
exports.replaceRule = replaceRule;
// 匹配是否需要替换内容
function includeReplaceContent(replaceFilePatternList, targetRelativeFile) {
    for (const pattern of replaceFilePatternList) {
        if (typeof pattern === 'string' && !/\*/.test(pattern)) {
            if (pattern === targetRelativeFile) {
                return true;
            }
        }
        else {
            const result = minimatch_1.default(targetRelativeFile, pattern, {
                matchBase: true,
            });
            if (result) {
                return true;
            }
        }
    }
    return false;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicnVsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9ydWxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSw4Q0FBZ0M7QUFFaEMsK0JBQWdEO0FBQ2hELDBEQUFrQztBQUNsQyxNQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBRXBEOzs7R0FHRztBQUNJLE1BQU0sVUFBVSxHQUFHLEtBQUssRUFDN0IsZUFBZSxFQUNmLGVBQWdDLEVBQ2hDLEVBQUU7SUFDRixNQUFNLFFBQVEsR0FBRyxlQUFRLENBQUMsZUFBZSxDQUFDLGtCQUFrQixDQUFDLENBQUM7SUFDOUQsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFO1FBQ3ZCLElBQUksZUFBZSxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsZUFBZSxDQUFDLEVBQUU7WUFDeEQsb0JBQW9CO1lBQ3BCLE1BQU0sV0FBVyxHQUFHLGVBQWUsQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLGVBQWUsQ0FBQyxDQUFDO1lBQ3pFLE1BQU0sT0FBTyxHQUFHLFdBQUksQ0FDbEIsZUFBZSxDQUFDLFNBQVMsRUFDekIsZUFBUSxDQUFDLGVBQWUsQ0FBQyxTQUFTLEVBQUUsV0FBVyxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FDbEUsQ0FBQztZQUNGLE1BQU0sR0FBRyxDQUFDLE1BQU0sQ0FBQyxXQUFXLEVBQUUsT0FBTyxDQUFDLENBQUM7WUFDdkMsZUFBZSxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsZUFBZSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQzlELEtBQUssQ0FBQyxrQkFBa0IsT0FBTyxFQUFFLENBQUMsQ0FBQztTQUNwQzthQUFNO1lBQ0wsTUFBTSxPQUFPLEdBQUcsV0FBSSxDQUNsQixlQUFlLENBQUMsU0FBUyxFQUN6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