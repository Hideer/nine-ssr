"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getClientWebpack = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const ssr_server_utils_1 = require("ssr-server-utils");
const base_1 = require("./base");
const safePostCssParser = require('postcss-safe-parser');
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
const generateAnalysis = Boolean(process.env.GENERATE_ANALYSIS);
const loadModule = require.resolve;
let asyncChunkMap = {};
const getClientWebpack = (chain) => {
    const { isDev, chunkName, getOutput, useHash, chainClientConfig } = (0, ssr_server_utils_1.loadConfig)();
    const shouldUseSourceMap = isDev || Boolean(process.env.GENERATE_SOURCEMAP);
    const publicPath = (0, ssr_server_utils_1.getOutputPublicPath)();
    (0, base_1.getBaseConfig)(chain, false);
    chain.devtool(isDev ? 'cheap-module-source-map' : (shouldUseSourceMap ? 'source-map' : false));
    chain.entry(chunkName)
        .add(loadModule('../entry/client-entry'))
        .end()
        .output
        .path(getOutput().clientOutPut)
        .filename(useHash ? 'static/js/[name].[contenthash:8].js' : 'static/js/[name].js')
        .chunkFilename(useHash ? 'static/js/[name].[contenthash:8].chunk.js' : 'static/js/[name].chunk.js')
        .publicPath(publicPath)
        .end();
    chain.optimization
        .runtimeChunk(true)
        .splitChunks({
        chunks: 'all',
        name(module, chunks, cacheGroupKey) {
            return (0, ssr_server_utils_1.cryptoAsyncChunkName)(chunks, asyncChunkMap);
        },
        cacheGroups: {
            vendors: {
                test: (module) => {
                    return module.resource &&
                        /\.js$/.test(module.resource) &&
                        module.resource.match('node_modules');
                },
                name: 'vendor'
            }
        }
    })
        .when(!isDev, optimization => {
        optimization.minimizer('terser')
            .use(loadModule('terser-webpack-plugin'), [{
                terserOptions: {
                    parse: {
                        ecma: 8
                    },
                    compress: {
                        ecma: 5,
                        warnings: false,
                        comparisons: false,
                        inline: 2
                    },
                    mangle: {
                        safari10: true
                    },
                    output: {
                        ecma: 5,
                        comments: false,
                        ascii_only: true
                    }
                },
                extractComments: false,
                parallel: true,
                cache: true,
                sourceMap: shouldUseSourceMap
            }]);
        optimization.minimizer('optimize-css').use(loadModule('optimize-css-assets-webpack-plugin'), [{
                cssProcessorOptions: {
                    parser: safePostCssParser,
                    map: shouldUseSourceMap ? {
                        inline: false,
                        annotation: true
                    } : false
                }
            }]);
    });
    chain.plugin('manifest').use(loadModule('webpack-manifest-plugin'), [{
            fileName: 'asset-manifest.json'
        }]);
    chain.when(generateAnalysis, chain => {
        chain.plugin('analyze').use(BundleAnalyzerPlugin);
    });
    chain.plugin('WriteAsyncManifest').use(class WriteAsyncChunkManifest {
        apply(compiler) {
            compiler.hooks.watchRun.tap('thisCompilation', async () => {
                // 每次构建前清空上一次的 chunk 信息
                asyncChunkMap = {};
            });
            compiler.hooks.done.tapAsync('WriteAsyncChunkManifest', async (params, callback) => {
                await fs_1.promises.writeFile((0, path_1.resolve)((0, ssr_server_utils_1.getCwd)(), './build/asyncChunkMap.json'), JSON.stringify(asyncChunkMap));
                callback();
            });
        }
    });
    chainClientConfig(chain); // 合并用户自定义配置
    return chain.toConfig();
};
exports.getClientWebpack = getClientWebpack;
