{"ast":null,"code":"import _toArray from \"@babel/runtime/helpers/toArray\";\n// @ts-nocheck\nimport { pathToRegexp } from 'path-to-regexp';\nvar cache = {};\nvar cacheLimit = 10000;\nvar cacheCount = 0;\n\nfunction compilePath(path, options) {\n  var cacheKey = \"\".concat(options.end).concat(options.strict).concat(options.sensitive);\n  var pathCache = cache[cacheKey] || (cache[cacheKey] = {});\n  if (pathCache[path]) return pathCache[path];\n  var keys = [];\n  var regexp = pathToRegexp(path, keys, options);\n  var result = {\n    regexp: regexp,\n    keys: keys\n  };\n\n  if (cacheCount < cacheLimit) {\n    pathCache[path] = result;\n    cacheCount++;\n  }\n\n  return result;\n}\n\nfunction matchPath(pathname) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof options === 'string' || Array.isArray(options)) {\n    options = {\n      path: options\n    };\n  }\n\n  var _options = options,\n      path = _options.path,\n      _options$exact = _options.exact,\n      exact = _options$exact === void 0 ? false : _options$exact,\n      _options$strict = _options.strict,\n      strict = _options$strict === void 0 ? false : _options$strict,\n      _options$sensitive = _options.sensitive,\n      sensitive = _options$sensitive === void 0 ? false : _options$sensitive;\n  var paths = [].concat(path);\n  return paths.reduce(function (matched, path) {\n    if (!path && path !== '') return null;\n    if (matched) return matched;\n\n    var _compilePath = compilePath(path, {\n      end: exact,\n      strict: strict,\n      sensitive: sensitive\n    }),\n        regexp = _compilePath.regexp,\n        keys = _compilePath.keys;\n\n    var match = regexp.exec(pathname);\n    if (!match) return null;\n\n    var _match = _toArray(match),\n        url = _match[0],\n        values = _match.slice(1);\n\n    var isExact = pathname === url;\n    if (exact && !isExact) return null;\n    return {\n      path: path,\n      url: path === '/' && url === '' ? '/' : url,\n      isExact: isExact,\n      params: keys.reduce(function (memo, key, index) {\n        memo[key.name] = values[index];\n        return memo;\n      }, {})\n    };\n  }, null);\n}\n\nfunction findRoute(Routes, path) {\n  // 根据请求的path来匹配到对应的Component\n  var route = Routes.find(function (route) {\n    return matchPath(path, route) && matchPath(path, route).isExact;\n  });\n  return route;\n}\n\nexport { findRoute };","map":{"version":3,"sources":["/Users/yumengcheng/Study/nine-ssr/node_modules/ssr-client-utils/esm/findRoute.js"],"names":["pathToRegexp","cache","cacheLimit","cacheCount","compilePath","path","options","cacheKey","end","strict","sensitive","pathCache","keys","regexp","result","matchPath","pathname","Array","isArray","exact","paths","concat","reduce","matched","match","exec","url","values","isExact","params","memo","key","index","name","findRoute","Routes","route","find"],"mappings":"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","sourcesContent":["// @ts-nocheck\nimport { pathToRegexp } from 'path-to-regexp';\nconst cache = {};\nconst cacheLimit = 10000;\nlet cacheCount = 0;\nfunction compilePath(path, options) {\n    const cacheKey = `${options.end}${options.strict}${options.sensitive}`;\n    const pathCache = cache[cacheKey] || (cache[cacheKey] = {});\n    if (pathCache[path])\n        return pathCache[path];\n    const keys = [];\n    const regexp = pathToRegexp(path, keys, options);\n    const result = { regexp, keys };\n    if (cacheCount < cacheLimit) {\n        pathCache[path] = result;\n        cacheCount++;\n    }\n    return result;\n}\nfunction matchPath(pathname, options = {}) {\n    if (typeof options === 'string' || Array.isArray(options)) {\n        options = { path: options };\n    }\n    const { path, exact = false, strict = false, sensitive = false } = options;\n    const paths = [].concat(path);\n    return paths.reduce((matched, path) => {\n        if (!path && path !== '')\n            return null;\n        if (matched)\n            return matched;\n        const { regexp, keys } = compilePath(path, {\n            end: exact,\n            strict,\n            sensitive\n        });\n        const match = regexp.exec(pathname);\n        if (!match)\n            return null;\n        const [url, ...values] = match;\n        const isExact = pathname === url;\n        if (exact && !isExact)\n            return null;\n        return {\n            path,\n            url: path === '/' && url === '' ? '/' : url,\n            isExact,\n            params: keys.reduce((memo, key, index) => {\n                memo[key.name] = values[index];\n                return memo;\n            }, {})\n        };\n    }, null);\n}\nfunction findRoute(Routes, path) {\n    // 根据请求的path来匹配到对应的Component\n    const route = Routes.find(route => matchPath(path, route) && matchPath(path, route).isExact);\n    return route;\n}\nexport { findRoute };\n"]},"metadata":{},"sourceType":"module"}